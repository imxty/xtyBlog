**何时要在属性前加:  v-bind**
=====================

如果传递的是字符串‘xxx’  可以不加，其他情况都要加

****El****
==========

指定根节点
![](../_v_images/_1582710311_10979.png)
****Template****
================

模板，只能有一个根节点
![](../_v_images/_1582710317_28714.png)
****Data****
============
![](../_v_images/_1582710323_30076.png)
****{{ }}****
=============

获取数据

****Methods****
===============
![](../_v_images/_1582710331_10884.png)
****Vue生命周期函数****
=================

****Created---数据加载****
----------------------

创建前拿不到msg，创建后就拿到了
![](../_v_images/_1582710344_12067.png)
****Mounted--Dom加载完成（JS生成的dom）****
----------------------------------
![](../_v_images/_1582710351_7691.png)
****Update--数据更新前后****
----------------------
![](../_v_images/_1582710359_25399.png)
****Destory--销毁前后****
---------------------
![](../_v_images/_1582710365_1400.png)
![](../_v_images/_1582710372_4881.png)
****Filters---过滤器****
=====================
![](../_v_images/_1582710379_28707.png)
****全局过滤器****
-------------
![](../_v_images/_1582710423_13718.png)
****数据绑定****
============

****V-bind--单向数据绑定****
----------------------

页面数据受控于JS，页面数据的改变不能改变JS，简写就是:
![](../_v_images/_1582710434_7688.png)
****V-model--双向****
-------------------
![](../_v_images/_1582710447_963.png)
****事件绑定****
============

****V-on****
------------

****监听****
==========

****Watch--单个监听****
-------------------
![](../_v_images/_1582710459_13009.png)
![](../_v_images/_1582710465_3228.png)
### ****深度监听****
![](../_v_images/_1582710478_29513.png)
![](../_v_images/_1582710485_10309.png)
****Computed--多个监听****
----------------------

触发条件（ 在computed中定义的每一个计算属性，都会被缓存起来，只有当计算属性里面依赖的一个或多个属性变化了，才会重新计算当前计算属性的值。上面的代码片段中，在reversedMessage中，它依赖了message和number这两个属性，一旦其中一个变化了，reversedMessage会立刻重新计算输出新值。）
![](../_v_images/_1582710500_16059.png)
****组件化****
===========

****方式1****
-----------
![](../_v_images/_1582710507_18886.png)
****方式2(还是要去component注册组件)****
------------------------------
![](../_v_images/_1582710514_12625.png)
****方式3(不用去注册了，直接用<my-fotter>)****
----------------------------------
![](../_v_images/_1582710519_17630.png)
****slot插槽****
==============
![](../_v_images/_1582710554_16157.png)
![](../_v_images/_1582710731_14174.png)
****父子间的通信****
==============

****父传子****
-----------
![](../_v_images/_1582710738_18574.png)
****子传父****
-----------
![](../_v_images/_1582710744_23124.png)
****非父子间通信****
==============
![](../_v_images/_1582710756_31598.png)
****路由跳转(监听hash锚点(url)的改变)****
==============================

****Vue-router--路由器****
-----------------------
![](../_v_images/_1582710765_24975.png)
****跳转方式****
------------

### ****Router-link****
![](../_v_images/_1582710780_11475.png)
### ****$router****
![](../_v_images/_1582710787_1089.png)
![](../_v_images/_1582710794_31668.png)
Replace没有历史记录

****路由传参****
============

****查询参数---相当于发送get请求  用？****
-----------------------------

/login?Id=123
![](../_v_images/_1582710811_24532.png)
获取id
![](../_v_images/_1582710815_18683.png)
****Params---相当于restful查询****
-----------------------------

/register/bar
![](../_v_images/_1582710822_11809.png)
![](../_v_images/_1582710828_14666.png)
获取参数
![](../_v_images/_1582710835_21168.png)
第二种获取参数的方式
![](../_v_images/_1582710842_21968.png)
![](../_v_images/_1582710848_7850.png)
****:key="$route.fullPath"****
------------------------------

如果只是改变参数的路径改变可能不会引起路由跳转，所以加上这个参数就可以监听整个路径包括参数的改变
![](../_v_images/_1582710855_19680.png)
****动态路由（path：********”********/aa/:id********”********）****
============================================================

****嵌套路由****
============

就是router-view里面又有一个router-view

/nav是一个 router-view （Nav）

/nav下面又有4个路由对应着/nav下的router-view
![](../_v_images/_1582710866_27040.png)
****路由守卫****
============

执行next()才会跳转，
![](../_v_images/_1582710874_6187.png)
**VeuX**
========
![](../_v_images/_1582710882_19804.png)
Actions:异步 通过this.$store.dispatch(“xxx”)触发

Mutations：同步 通过this.$store.commit(“xxx”)触发

****初始化 store****
-----------------
![](../_v_images/_1582710890_15811.png)
****第一种使用方法****
---------------
![](../_v_images/_1582710898_1358.png)
-->调用count函数获取
![](../_v_images/_1582710905_19036.png)
****第二种方式--辅助函数（需要多个数据的时候，省的一个一个拿）****
--------------------------------------
![](../_v_images/_1582710911_13912.png)
****将mapstate中的数据与本地computed中的数据混用****
--------------------------------------

只需要将mapstate展开（...运算符）...mapstate
![](../_v_images/_1582710918_22111.png)
****高级用法****
------------

### ****Getters---相当于computed****
![](../_v_images/_1582710926_18951.png)
使用（如果使用的字符串就数组）
![](../_v_images/_1582710931_13515.png)
### ****Modules模块化****

创建一个count的模块
![](../_v_images/_1582710937_8309.png)
创建模块化store
![](../_v_images/_1582710942_8706.png)
在main.js中引入相应的模块
![](../_v_images/_1582710947_13935.png)
使用
![](../_v_images/_1582710952_14816.png)
****创建项目****
============

Nodejs 输入 vue create 项目名字

****添加cube-ui****
-----------------

Vue》3.0  vue add cube-ui

****添加axios--->es6封装的ajax****
-----------------------------

Cnpm install axios

挂载axios
![](../_v_images/_1582710964_2449.png)
发送请求
![](../_v_images/_1582710968_30690.png)
****axios的配置****
================

****Axios实例创建****
-----------------
![](../_v_images/_1582710975_4723.png)
****Request请求拦截器****
--------------------
![](../_v_images/_1582710982_22817.png)
****Response拦截器****
-------------------
![](../_v_images/_1582710987_11557.png)
****挂载到vue****
--------------
![](../_v_images/_1582710991_14178.png)
****项目结构****
============

****Store.js----就是vuex****
--------------------------

this.$store.dispatch("increment");---调用action中的方法 （异步）

this.$store.commit("increment");---调用mutations方法 （同步）

****Axios的拦截****
================
![](../_v_images/_1582711002_19072.png)
****项目打包****
============

Cnpm run build

****MVVM****
============
![](../_v_images/_1582711009_28058.png)
****Mock****
============

****安装****
----------
![](../_v_images/_1582711086_22812.png)
****使用（url，请求方法，返回数据）****
-------------------------
![](../_v_images/_1582711093_6545.png)
****引入到vue****
--------------
![](../_v_images/_1582711097_2802.png)
****ElementUi****
=================

****安装****
----------

Yarn  add element-ui -S

****挂载****
----------
![](../_v_images/_1582711105_11138.png)
****布局组件的使用（el-row  content）****
--------------------------------

****弹出组件（dialog --->使用了sync  popover用的较少）****
---------------------------------------------

Sync就是为了实现props的双向绑定，sync就是添加了事件监听，然后子组件通过$emit(“update:xxx”,newVal)改变父组件内容

****表格表单组件****
--------------

Lable  就是表单的描述

V-model 就是表单数据的绑定

### ****表单验证rules****

****Scss和Sass--就是css解析器****
===========================

****Eslint---设置代码规则解析器，代码格式化****
================================

****Echarts****
===============